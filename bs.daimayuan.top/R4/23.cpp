#include <bits/stdc++.h>
using namespace std;

/**
 * @brief 异或和
 * 给你一个长度为 n 的数组 a，求所有子数组的异或和的和。
 * 
 * @Description
 * 异或可以看作无进位加法, 因此可以将问题转化为求每个二进制位上的贡献
 * 对于第 k 位, 我们可以枚举所有子数组的右端点 i, 然后统计以 i 为右端点的子数组中, 第 k 位为 1 的子数组的个数
 */
int main() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    long long sum = 0;  // 记录所有子数组的异或和的和
    for (int k = 0; k < 32; k++) {
        long long cnt = 0;  // 记录第k位为1的子数组数量
        int total = 0;      // 记录以当前位置i结尾的子数组中，第k位有奇数个1的子数组数量, 初始化为0
        /*
            total变量的精妙之处：
            total实际上维护的是：以当前位置i结尾的子数组中，第k位有奇数个1的子数组数量
            
            (位置i结尾的子数组)正好是所有(位置i-1结尾的子数组)末尾加上a[i], 再加上单元素数组[a[i]]
            a[i]的第k位为1时, 则
                (位置i-1结尾的子数组)的k位异或值0-1翻转: 原k位为1的子数组变成k位为0(total个),原k位为0子数组((i-1) - total个)变成k位为1
                单元素数组[a[i]]的k位异或值为1
            因此新的奇数个1的子数组数 = (i - 1) - total + 1 = i - total

            举例说明： 
            假设数组为[1,3,7]，计算第1位(k=1, start from 0)：
            i=1 (1): 子数组为 [1],                i=1(1个子数组) k位上为0 -> total=0, cnt=0
            i=2 (3): 子数组为 [1,3], [3],         i=2, k位上为1 -> total=2-0=2, cnt=0+2=2
            i=3 (7): 子数组为 [1,3,7], [3,7], [7] i=3, k位上为1 -> total=3-2=1, cnt=2+1=3
            最终第1位贡献：3×1=3
            
            这种方法的巧妙之处在于将O(n²)的子数组枚举优化为O(n)的按位处理，
            通过维护奇偶性状态来高效计算每位贡献。
        */
        
        for (int i = 1; i <= n; i++) {
            // 到第i个数结尾的子数组[l, i]的总个数为i个
            if (a[i] & (1 << k)) {
                // 如果a[i]的第k位为1
                // 遇到1时翻转奇偶性
                // total表示以i结尾的、第k位有奇数个1的子数组数量
                total = i - total;  // 巧妙之处：i是总子数组数，total是偶数个1的子数组数
            }
            cnt += total;  // 累加当前位的贡献
        }
        
        sum += cnt * (1LL << k);  // 将数量转换为实际贡献值
    }
    
    cout << sum << endl;
    return 0;
}